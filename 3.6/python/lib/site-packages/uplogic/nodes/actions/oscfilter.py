from uplogic.nodes import ULActionNode, ULOutSocket
from uplogic.utils import is_waiting, not_met


# OSC Filter Node Implementation
class ULOSCFilter(ULActionNode):
    def __init__(self):
        ULActionNode.__init__(self)
        
        # Input sockets
        self.queue_length = None
        self.messages_per_frame = None
        self.filter_repeats = None
        self.vector_mode = None # New vector mode filtering
        self.repeat_threshold = None
        self.drop_overflow = None
        self.default_address = None  # Moved from SetupOSCServer
        self.address_filter = None
        
        # Output socket with filter configuration
        self.FILTER_CONFIG = ULOutSocket(self, self.get_filter_config)
        
        # Storage for last values (used for repeat filtering)
        self._last_values = {}
    
    def get_filter_config(self):
        # Create config dictionary with all filter settings
        config = {
            "default_address": self.get_input(self.default_address),
            "queue_length": self.get_input(self.queue_length),
            "messages_per_frame": self.get_input(self.messages_per_frame),
            "filter_repeats": self.get_input(self.filter_repeats),
            "vector_mode": self.get_input(self.vector_mode),
            "repeat_threshold": self.get_input(self.repeat_threshold),
            "drop_overflow": self.get_input(self.drop_overflow),
            "address_filter": self.get_input(self.address_filter),
            "last_values": self._last_values  # Internal state for repeat filtering
        }
        return config
    
    def evaluate(self):
        # Just make sure we're ready
        self._set_ready()
        # All the actual work happens when the filter config is passed to the OSC server
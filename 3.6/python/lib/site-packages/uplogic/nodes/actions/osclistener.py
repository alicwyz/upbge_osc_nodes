from uplogic.nodes import ULActionNode, ULOutSocket
from uplogic.utils import is_waiting, not_met
import re
from collections import defaultdict

class ULOSCListener(ULActionNode):
    def __init__(self):
        ULActionNode.__init__(self)
        
        # Input sockets
        self.messages = None
        self.address_patterns = None
        self.common_prefix = None
        
        # Output sockets
        self.ANY_RECEIVED = ULOutSocket(self, self.get_any_received)
        self.MESSAGES = ULOutSocket(self, self.get_messages)
        
        # Internal state
        self._any_received = False
        self._matched_messages = {}
        self._address_patterns = []
        #self._pattern_cache = {}  # Cache for compiled wildcard patterns
        
    def get_any_received(self):
        return self._any_received
    
    def get_messages(self):
        return self._matched_messages
    
    def _compile_address_patterns(self, address_filter, common_prefix):
        """Compile regex patterns from address filter string"""
        self._address_patterns = []
        
        #No filter informed
        if not address_filter:
            return
        
        # Split by comma or semicolon and trim whitespace
        patterns = [p.strip() for p in re.split(r'[,;]', address_filter) if p.strip()]
        
        full_patterns = [common_prefix + pattern for pattern in patterns]
        
        for pattern in full_patterns:
            # Convert OSC-style wildcards to regex patterns
            if '*' in pattern:
                # Escape dots and other regex special chars except *
                pattern = re.escape(pattern).replace('\\*', '.*')
                self._address_patterns.append(re.compile(f'^{pattern}$'))
            else:
                # Exact match for addresses without wildcards
                self._address_patterns.append(re.compile(f'^{re.escape(pattern)}$'))
    
    def evaluate(self):
        _messages = self.get_input(self.messages)
        _address_patterns_str = self.get_input(self.address_patterns)
        _common_prefix = self.get_input(self.common_prefix) or ""
        
        self._set_ready()
        
        # Reset state for this evaluation cycle
        self._any_received = False
        new_matches = {}
        
        # No messages or no patterns to match
        if not _messages or not _address_patterns_str:
            return
        
        self._compile_address_patterns(_address_patterns_str, _common_prefix)
        
        # Split the pattern string into individual patterns
        #_address_patterns = self._split_patterns(_address_patterns_str)
        
        # Apply common prefix to all patterns if specified
        #full_patterns = [_common_prefix + pattern for pattern in _address_patterns]
        
        # Process incoming messages
        for address, value in list(_messages.items()):
            # Check each pattern against this address
            for pattern in self._address_patterns:
                if pattern.match(address):
                    # Match found - store value and mark received
                    new_matches[address] = value
                    self._any_received = True
                    
                    # Remove processed message
                    _messages.pop(address, None)
        
        # Update matched messages
        self._matched_messages.update(new_matches)
        
    '''
    def _compile_pattern(self, pattern):
        """Convert OSC pattern to regex pattern and compile it"""
        if pattern in self._pattern_cache:
            return self._pattern_cache[pattern]
            
        # Handle OSC-style pattern matching
        # Replace OSC pattern characters with regex equivalents
        regex_pattern = pattern
        
        # Handle character classes [...]
        regex_pattern = re.sub(r'\[([^\]]*)\]', lambda m: '[' + m.group(1) + ']', regex_pattern)
        
        # Handle negated character classes [!...]
        regex_pattern = re.sub(r'\[!([^\]]*)\]', lambda m: '[^' + m.group(1) + ']', regex_pattern)
        
        # Handle alternatives {a,b,c}
        regex_pattern = re.sub(r'\{([^}]*)\}', lambda m: '(' + m.group(1).replace(',', '|') + ')', regex_pattern)
        
        # Handle wildcards
        regex_pattern = regex_pattern.replace('*', '.*')
        regex_pattern = regex_pattern.replace('?', '.')
        
        # Ensure the pattern matches the full address string
        regex_pattern = '^' + regex_pattern + '$'
        
        # Compile the regex
        compiled = re.compile(regex_pattern)
        self._pattern_cache[pattern] = compiled
        return compiled
    
    def _matches_pattern(self, address, pattern):
        """Check if address matches the given pattern"""
        if '*' not in pattern and '?' not in pattern and '[' not in pattern and '{' not in pattern:
            # Optimization for exact match patterns
            return address == pattern
            
        compiled_pattern = self._compile_pattern(pattern)
        return compiled_pattern.match(address) is not None
    
    def _split_patterns(self, pattern_string):
        """Split the pattern string into a list of patterns, respecting commas inside brackets and braces"""
        if not pattern_string or pattern_string.strip() == "":
            return []
            
        patterns = []
        current = ""
        brace_level = 0
        bracket_level = 0
        
        for char in pattern_string:
            if char == ',' and brace_level == 0 and bracket_level == 0:
                # Split on commas, but only at the top level
                patterns.append(current.strip())
                current = ""
            else:
                current += char
                # Track nesting of braces and brackets
                if char == '{':
                    brace_level += 1
                elif char == '}':
                    brace_level = max(0, brace_level - 1)
                elif char == '[':
                    bracket_level += 1
                elif char == ']':
                    bracket_level = max(0, bracket_level - 1)
        
        # Add the last pattern if not empty
        if current.strip():
            patterns.append(current.strip())
            
        return patterns
    '''
from uplogic.nodes import ULActionNode, ULOutSocket
from uplogic.utils import is_waiting, not_met
from pythonosc import dispatcher, osc_server, osc_bundle
import threading
import queue
import re

# Setup OSC Server Node with Performance Optimizations
class ULSetupOSCServer(ULActionNode):
    def __init__(self):
        ULActionNode.__init__(self)
        
        #inputs
        self.condition_start = None
        self.condition_stop = None
        self.ip = None
        self.port = None
        self.filters = None  # New filters input # Now includes default_address
        self.debug = None  # Debug toggle
        
        self.MESSAGES = ULOutSocket(self, self.get_messages)
        
        self._server = None
        self._server_thread = None
        self._dispatcher = dispatcher.Dispatcher()
        self._messages = {}
        self._message_queue = None  # Will be initialized with filter config
        self._processing_thread = None
        self._running = False
        
        # Default filter configuration
        self._filter_config = {
            "default_address": "",
            "queue_length": 100,
            "messages_per_frame": 10,
            "filter_repeats": False,
            "vector_mode": False,
            "repeat_threshold": 0.001,
            "drop_overflow": True,
            "address_filter": "",
            "last_values": {}
        }
        
        # Compiled regex patterns for address filtering
        self._address_patterns = []
    
    def get_messages(self):
        return self._messages
    
    def _should_process_message(self, address, value):
        """Determine if a message should be processed based on filter settings"""
        # Check address filter first
        if self._address_patterns:
            match_found = False
            for pattern in self._address_patterns:
                if pattern.match(address):
                    match_found = True
                    break
            if not match_found:
                return False     
        
        
        # Check for repeating messages if enabled
        if self._filter_config["filter_repeats"] and address in self._filter_config["last_values"]:
            last_value = self._filter_config["last_values"][address]
            
            if value == last_value:
                return False
            # Handle different value types
            elif isinstance(value, (float)) and isinstance(last_value, (float)):
                if abs(value - last_value) < self._filter_config["repeat_threshold"]:
                    return False
             # More sophisticated list handling:
            elif self._filter_config["vector_mode"]: #Filter lists?
                if isinstance(value, list) and isinstance(last_value, list) and len(value) == len(last_value):
                    # Check if all elements are within threshold
                    for i in range(len(value)):
                        if value[i] == last_value[i]:
                            return False
                        elif isinstance(value[i], (float)) and isinstance(last_value[i], (float)):
                            if abs(value[i] - last_value[i]) < self._filter_config["repeat_threshold"]:
                                return False
                
        # Store the current value for future comparison
        self._filter_config["last_values"][address] = value
        return True
    
    def message_handler(self, address, *args):
        """Handles OSC messages and applies filtering"""
        try:
            # Process single messages
            if not isinstance(args[0], osc_bundle.OscBundle):
                value = None
                if len(args) == 1:
                    value = args[0]  # Single value
                elif len(args) > 1:
                    value = list(args)  # Multiple values as a list
                
                # Apply message filtering
                if self._should_process_message(address, value):
                    try:
                        if self._filter_config["drop_overflow"]:
                            self._message_queue.put_nowait((address, value))
                        else:
                            self._message_queue.put((address, value))
                    except queue.Full:
                        if self.get_input(self.debug):
                            print(f"OSC Warning: Message queue is full, dropping message: {address}")
            # Process bundles
            else:
                for msg in args[0].messages:
                    bundle_address = msg[0]
                    bundle_value = msg[1]
                    
                    # Apply filtering to each message in the bundle
                    if self._should_process_message(bundle_address, bundle_value):
                        try:
                            if self._filter_config["drop_overflow"]:
                                self._message_queue.put_nowait((bundle_address, bundle_value))
                            else:
                                self._message_queue.put((bundle_address, bundle_value))
                        except queue.Full:
                            if self.get_input(self.debug):
                                print(f"OSC Warning: Message queue is full, dropping bundle message: {bundle_address}")
                                
        except Exception as e:
            if self.get_input(self.debug):
                print(f"OSC Error in message handler: {e}")
    
    
    def process_messages(self):
        """Process messages from the queue with rate limiting"""
        while self._running:
            try:
                # Get the current messages_per_frame setting
                msgs_per_frame = self._filter_config["messages_per_frame"]
                
                # Process up to messages_per_frame messages
                for _ in range(msgs_per_frame):
                    address, value = self._message_queue.get(timeout=0.1)
                    self._messages[address] = value
                    if self.get_input(self.debug):
                        print(f"OSC Debug: {address} -> {value}")
                    self._message_queue.task_done()
            except queue.Empty:
                pass  # No messages to process  
    
    def evaluate(self):
        #Get input
        _start = self.get_input(self.condition_start)
        _stop = self.get_input(self.condition_stop)
        _ip = self.get_input(self.ip)
        _port = self.get_input(self.port)
        
        # Get filter configuration if connected
        filter_input = self.get_input(self.filters)
        if filter_input:
            self._filter_config.update(filter_input)
        
        #Set Ready
        self._set_ready()

        # Start server if triggered
        if _start and self._server is None:
            try:
                # Initialize queue with configured length
                self._message_queue = queue.Queue(maxsize=self._filter_config["queue_length"])
                
                # Compile address filter patterns
                self._compile_address_patterns(self._filter_config["address_filter"])
                
                # Set up the dispatcher and server
                # Now using default_address from filter config
                default_addr = self._filter_config["default_address"] or "/*"
                self._dispatcher.map(default_addr, self.message_handler)
                self._server = osc_server.ThreadingOSCUDPServer((_ip, _port), self._dispatcher)
                self._server_thread = threading.Thread(target=self._server.serve_forever, daemon=True)
                self._server_thread.start()
                
                # Start processing thread
                self._running = True
                self._processing_thread = threading.Thread(target=self.process_messages, daemon=True)
                self._processing_thread.start()
                
                if self.get_input(self.debug):
                    filter_info = ""
                    if filter_input:
                        filter_info += f", Default address: {default_addr}"
                        filter_info += f", Queue: {self._filter_config['queue_length']}, Msgs/frame: {self._filter_config['messages_per_frame']}"
                    
                    if self._filter_config["filter_repeats"]:
                        filter_info += f", Filtering repeats (threshold: {self._filter_config['repeat_threshold']})"
                    
                    if self._address_patterns:
                        filter_info += f", Advanced filter: {self._filter_config['address_filter']}"
                    
                    print(f"OSC Server started at {_ip}:{_port}{filter_info}")
            
            except Exception as e:
                print(f"OSC Server Error: {e}")
                self._server = None

        # Stop server if triggered
        if _stop and self._server is not None:
            self._server.shutdown()
            self._server_thread.join()
            self._server = None
            self._running = False
            self._processing_thread.join()
            
            # Clear message queue and filtered values
            self._message_queue = None
            self._filter_config["last_values"] = {}
            
            if self.get_input(self.debug):
                print("OSC Server stopped")
    
    
    def _compile_address_patterns(self, address_filter):
        """Compile regex patterns from address filter string"""
        self._address_patterns = []
        
        #No filter informed
        if not address_filter:
            return
        
        # Split by comma or semicolon and trim whitespace
        patterns = [p.strip() for p in re.split(r'[,;]', address_filter) if p.strip()]
        
        for pattern in patterns:
            # Convert OSC-style wildcards to regex patterns
            if '*' in pattern:
                # Escape dots and other regex special chars except *
                pattern = re.escape(pattern).replace('\\*', '.*')
                self._address_patterns.append(re.compile(f'^{pattern}$'))
            else:
                # Exact match for addresses without wildcards
                self._address_patterns.append(re.compile(f'^{re.escape(pattern)}$'))
        
        '''
        patterns = self._split_patterns(address_filter)
        
        # Allows for more complex regex patterns
        for pattern in patterns:
            if '*' not in pattern and '?' not in pattern and '[' not in pattern and '{' not in pattern:
                 # Exact match for addresses without wildcards
                self._address_patterns.append(re.compile(f'^{re.escape(pattern)}$'))
            else:
                # Convert OSC-style wildcards to regex patterns
                compiled = self._compile_pattern(pattern)
                self._address_patterns.append(compiled)
        
        '''
        
      
          

# Performance Improvements:
# ✅ Dedicated Thread for Processing Messages: Messages are now queued and processed in a separate thread.
# ✅ Optimized Data Storage: Only the latest value per OSC address is stored.
# ✅ Batch Processing: The processing thread handles messages in groups of 10 to reduce frame lag.
# ✅ Limited Processed Messages Per Frame: Prevents too many messages from slowing down UPBGE.
# ✅ UDP Buffer Adjustments: The message queue prevents the UDP buffer from overflowing.

# Filtering Improvements:
# ✅ Configurable Message Queue: Adjustable queue length based on application needs
# ✅ Adjustable Processing Rate: Control how many messages are processed per frame
# ✅ Repeat Filtering: Option to filter out redundant messages with configurable threshold
# ✅ OSC Address Filtering: Filter messages based on address patterns
# ✅ Overflow Handling: Option to either block or drop messages when queue is full
# ✅ Detailed Debug Info: More comprehensive debug information about filtering

# Address FIltering
#/fader1 would match only messages with exactly that address
#/button/* would match any message starting with /button/
#/*/intensity would match addresses like /light1/intensity, /light2/intensity, etc.

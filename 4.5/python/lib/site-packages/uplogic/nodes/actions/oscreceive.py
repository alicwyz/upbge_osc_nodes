from uplogic.nodes import ULActionNode
import re

class ULOSCReceive(ULActionNode):
    def __init__(self):
        ULActionNode.__init__(self)
        
        # Inputs
        self.messages = None
        self.osc_address = None
        
        # Outputs
        self.RECEIVED = self.add_output(self._get_received)
        self.MESSAGES = self.add_output(self._get_messages)
        self.VALUE = self.add_output(self._get_value)
        
        # Internals
        self._received = False
        self._out_messages = {}
        self._value = None
        
        # Compiled regex patterns for address filtering
        self._valid_addresses = set() 
        self._valid_patterns = []
        self._last_address = ""
        
    def _get_received(self):
        return self._received
    
    def _get_value(self):
        return self._value
    
    def _get_messages(self):
        return self._out_messages
    
    def evaluate(self):
        _messages = self.get_input(self.messages)
        _address = self.get_input(self.osc_address)
        
        if _address != self._last_address:
            # Setup address 
            self._setup_filters(_address)
            self._last_address = _address
        
        if _messages:  
            self._received = False
            for address, value in _messages.items():
                if self._match_message(address, value):
                    self._received = True
        
    def _setup_filters(self, address):
        # Split based on , or ;
        addresses = re.split(r'[,;]', address)   
        for addr in addresses:
            addr = addr.strip()
            if '*' in addr:
                escaped_addr = re.escape(addr)  # Escape special regex characters
                escaped_addr = escaped_addr.replace(r'\*', '.*')  # Replace escaped '*' with '.*'
                regex_pattern = re.compile(f"^{escaped_addr}$")  # Now correctly formatted
                self._valid_patterns.append(regex_pattern)
            else:
                self._valid_addresses.add(addr)  # Exact match optimization

    def _match_message(self, address, value):
        """Determine if a message should be processed based on filter settings."""
        
         # Check exact matches
        if self._valid_addresses and address in self._valid_addresses:
            # Exact match found
            self._value = value
            self._out_messages[address] = value
            return True  
        
        # Check regex wildcard matches
        elif self._valid_patterns:
            if any(pattern.match(address) for pattern in self._valid_patterns):
                # Match found
                self._value = value 
                self._out_messages[address] = value
                return True
            
        return False
    
        # If osc_address has only one address, value will output a single value
        # If osc_address has many addresses, value will output last checked address (?)